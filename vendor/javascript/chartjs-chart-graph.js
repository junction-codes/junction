// chartjs-chart-graph@4.3.4 downloaded from https://ga.jspm.io/npm:chartjs-chart-graph@4.3.4/build/index.js

import{LineElement as e,registry as t,ScatterController as s,defaults as r,Chart as a,PointElement as n,LinearScale as o}from"chart.js";import{unlistenArrayEvents as i,listenArrayEvents as l,clipArea as d,unclipArea as c,merge as h}from"chart.js/helpers";import{forceSimulation as p,forceCenter as u,forceCollide as m,forceLink as g,forceManyBody as y,forceX as _,forceY as x,forceRadial as f}from"d3-force";import{hierarchy as E,tree as v,cluster as C}from"d3-hierarchy";function horizontal(e,t,s){return{fx:(t.x-e.x)*s.tension,fy:0,tx:(e.x-t.x)*s.tension,ty:0}}function vertical(e,t,s){return{fx:0,fy:(t.y-e.y)*s.tension,tx:0,ty:(e.y-t.y)*s.tension}}function radial(e,t,s){const r=Math.hypot(t.x-e.x,t.y-e.y)*s.tension;return{fx:Number.isNaN(e.angle)?0:Math.cos(e.angle||0)*r,fy:Number.isNaN(e.angle)?0:Math.sin(e.angle||0)*-r,tx:Number.isNaN(t.angle)?0:Math.cos(t.angle||0)*-r,ty:Number.isNaN(t.angle)?0:Math.sin(t.angle||0)*r}}class EdgeLine extends e{draw(e){const{options:t}=this;e.save();e.lineCap=t.borderCapStyle;e.setLineDash(t.borderDash||[]);e.lineDashOffset=t.borderDashOffset;e.lineJoin=t.borderJoinStyle;e.lineWidth=t.borderWidth;e.strokeStyle=t.borderColor;const s={horizontal:horizontal,vertical:vertical,radial:radial};const r=s[this._orientation]||s.horizontal;const renderLine=(s,a)=>{const n=r(s,a,t);const o={cpx:s.x+n.fx,cpy:s.y+n.fy};const i={cpx:a.x+n.tx,cpy:a.y+n.ty};if(t.stepped==="middle"){const t=(s.x+a.x)/2;e.lineTo(t,s.y);e.lineTo(t,a.y);e.lineTo(a.x,a.y)}else if(t.stepped==="after"){e.lineTo(s.x,a.y);e.lineTo(a.x,a.y)}else if(t.stepped){e.lineTo(a.x,s.y);e.lineTo(a.x,a.y)}else t.tension?e.bezierCurveTo(o.cpx,o.cpy,i.cpx,i.cpy,a.x,a.y):e.lineTo(a.x,a.y);return a};const a=this.source.getProps(["x","y","angle"]);const n=this.target.getProps(["x","y","angle"]);const o=this.getProps(["points"]).points;e.beginPath();let i=a;e.moveTo(i.x,i.y);o&&o.length>0&&(i=o.reduce(renderLine,i));renderLine(i,n);e.stroke();if(t.directed){const s=n;const a=r(i,s,t);const o=t.arrowHeadSize;const l=t.arrowHeadOffset;e.save();e.translate(s.x,n.y);if(t.stepped==="middle"){const t=(i.x+s.x)/2;e.rotate(Math.atan2(s.y-s.y,s.x-t))}else if(t.stepped==="after")e.rotate(Math.atan2(s.y-s.y,s.x-i.x));else if(t.stepped)e.rotate(Math.atan2(s.y-i.y,s.x-s.x));else if(t.tension){const t={x:s.x+a.tx,y:s.y+a.ty};const r=.1;e.rotate(Math.atan2(s.y-t.y*(1-r)-i.y*r,s.x-t.x*(1-r)-i.x*r))}else e.rotate(Math.atan2(s.y-i.y,s.x-i.x));e.translate(-l,0);e.beginPath();e.moveTo(0,0);e.lineTo(-o,-o/2);e.lineTo(.9*-o,0);e.lineTo(-o,o/2);e.closePath();e.fillStyle=e.strokeStyle;e.fill();e.restore()}e.restore()}}EdgeLine.id="edgeLine";EdgeLine.defaults={...e.defaults,tension:0,directed:false,arrowHeadSize:15,arrowHeadOffset:5};EdgeLine.defaultRoutes=e.defaultRoutes;EdgeLine.descriptors={_scriptable:true,_indexable:e=>e!=="borderDash"};function interpolateNumber(e,t,s){return e===t?t:e+(t-e)*s}function interpolatorPoint(e,t,s,r){const a=e[t]||e[t-1]||e._source;if(!a)return s;const n=interpolateNumber(a.x,s.x,r);const o=interpolateNumber(a.y,s.y,r);const i=Number.isNaN(a.angle)?interpolateNumber(a.angle,s.angle,r):void 0;return{x:n,y:o,angle:i}}function interpolatePoints(e,t,s){return Array.isArray(e)&&Array.isArray(t)&&t.length>0?t.map(((t,r)=>interpolatorPoint(e,r,t,s))):t}function patchController(e,s,r,a=[],n=[]){t.addControllers(r);Array.isArray(a)?t.addElements(...a):t.addElements(a);Array.isArray(n)?t.addScales(...n):t.addScales(n);const o=s;o.type=e;return o}class GraphController extends s{constructor(){super(...arguments);this._scheduleResyncLayoutId=-1;this._edgeListener={_onDataPush:(...e)=>{const t=e.length;const s=this.getDataset().edges.length-t;const r=this._cachedMeta._parsedEdges;e.forEach((e=>{r.push(this._parseDefinedEdge(e))}));this._insertEdgeElements(s,t)},_onDataPop:()=>{this._cachedMeta.edges.pop();this._cachedMeta._parsedEdges.pop();this._scheduleResyncLayout()},_onDataShift:()=>{this._cachedMeta.edges.shift();this._cachedMeta._parsedEdges.shift();this._scheduleResyncLayout()},_onDataSplice:(e,t,...s)=>{this._cachedMeta.edges.splice(e,t);this._cachedMeta._parsedEdges.splice(e,t);if(s.length>0){const t=this._cachedMeta._parsedEdges;t.splice(e,0,...s.map((e=>this._parseDefinedEdge(e))));this._insertEdgeElements(e,s.length)}else this._scheduleResyncLayout()},_onDataUnshift:(...e)=>{const t=this._cachedMeta._parsedEdges;t.unshift(...e.map((e=>this._parseDefinedEdge(e))));this._insertEdgeElements(0,e.length)}}}initialize(){const e=this._type;const s=r.datasets[e];this.edgeElementType=t.getElement(s.edgeElementType);super.initialize();this.enableOptionSharing=true;this._scheduleResyncLayout()}parse(e,t){const s=this._cachedMeta;const r=this._data;const{iScale:a,vScale:n}=s;for(let a=0;a<t;a+=1){const t=a+e;const n=r[t];const o=s._parsed[t]||{};n&&typeof n.x==="number"&&(o.x=n.x);n&&typeof n.y==="number"&&(o.y=n.y);s._parsed[t]=o}s._parsed.length>r.length&&s._parsed.splice(r.length,s._parsed.length-r.length);this._cachedMeta._sorted=false;a._dataLimitsCached=false;n._dataLimitsCached=false;this._parseEdges()}reset(){this.resetLayout();super.reset()}update(e){super.update(e);const t=this._cachedMeta;const s=t.edges||[];this.updateEdgeElements(s,0,e)}_destroy(){s.prototype._destroy.call(this);this._edges&&i(this._edges,this._edgeListener);this.stopLayout()}updateEdgeElements(e,t,s){var r,a,n;const o={_cachedDataOpts:this._cachedDataOpts,dataElementType:this.dataElementType,_sharedOptions:this._sharedOptions};this._cachedDataOpts={};this.dataElementType=this.edgeElementType;this._sharedOptions=this._edgeSharedOptions;const i=this.getDataset();const l=this._cachedMeta;const d=l.data;const c=this._cachedMeta._parsedEdges;this.getContext(-1,false,s);this.getDataset=()=>new Proxy(i,{get(e,t){var s;return t==="data"?(s=e.edges)!==null&&s!==void 0?s:[]:e[t]}});this.getParsed=e=>c[e];l.data=l.edges;const h=s==="reset";const p=this.resolveDataElementOptions(t,s);const u={};const m=(r=this.getSharedOptions(p))!==null&&r!==void 0?r:u;const g=this.includeOptions(s,m);const{xScale:y,yScale:_}=l;const x={x:(a=y===null||y===void 0?void 0:y.getBasePixel())!==null&&a!==void 0?a:0,y:(n=_===null||_===void 0?void 0:_.getBasePixel())!==null&&n!==void 0?n:0};function copyPoint(e){var t,s;const r=h?x.x:(t=y===null||y===void 0?void 0:y.getPixelForValue(e.x,0))!==null&&t!==void 0?t:0;const a=h?x.y:(s=_===null||_===void 0?void 0:_.getPixelForValue(e.y,0))!==null&&s!==void 0?s:0;return{x:r,y:a,angle:e.angle}}for(let r=0;r<e.length;r+=1){const a=e[r];const n=t+r;const o=c[n];const i={source:d[o.source],target:d[o.target],points:Array.isArray(o.points)?o.points.map((e=>copyPoint(e))):[]};i.points._source=d[o.source];g&&(i.options=m!==u?m:this.resolveDataElementOptions(n,s));this.updateEdgeElement(a,n,i,s)}this.updateSharedOptions(m,s,p);this._edgeSharedOptions=this._sharedOptions;Object.assign(this,o);delete this.getDataset;delete this.getParsed;l.data=d}updateEdgeElement(e,t,s,r){super.updateElement(e,t,s,r)}updateElement(e,t,s,r){var a;if(r==="reset"){const{xScale:e}=this._cachedMeta;s.x=(a=e===null||e===void 0?void 0:e.getBasePixel())!==null&&a!==void 0?a:0}super.updateElement(e,t,s,r)}resolveNodeIndex(e,t){if(typeof t==="number")return t;if(typeof t==="string"){const e=this.chart.data.labels;return e.indexOf(t)}const s=e.indexOf(t);if(s>=0)return s;const r=this.getDataset().data;const a=r.indexOf(t);if(a>=0)return a;console.warn("cannot resolve edge ref",t);return-1}buildOrUpdateElements(){const e=this.getDataset();const t=e.edges||[];if(this._edges!==t){this._edges&&i(this._edges,this._edgeListener);t&&Object.isExtensible(t)&&l(t,this._edgeListener);this._edges=t}super.buildOrUpdateElements()}draw(){const e=this._cachedMeta;const t=this._cachedMeta.edges||[];const s=e.data||[];const r=this.chart.chartArea;const a=this._ctx;if(t.length>0){d(a,r);t.forEach((e=>e.draw.call(e,a,r)));c(a)}s.forEach((e=>e.draw.call(e,a,r)))}_resyncElements(){s.prototype._resyncElements.call(this);const e=this._cachedMeta;const t=e._parsedEdges;const r=e.edges||(e.edges=[]);const a=r.length;const n=t.length;if(n<a){r.splice(n,a-n);this._scheduleResyncLayout()}else n>a&&this._insertEdgeElements(a,n-a)}getTreeRootIndex(){const e=this.getDataset();const t=e.data;if(e.derivedEdges)return t.findIndex((e=>e.parent==null));const s=this._cachedMeta._parsedEdges||[];const r=new Set(t.map(((e,t)=>t)));s.forEach((e=>{r.delete(e.target)}));return Array.from(r)[0]}getTreeRoot(){const e=this.getTreeRootIndex();const t=this.getParsed(e);t.index=e;return t}getTreeChildren(e){var t;const s=this._cachedMeta._parsedEdges;const r=(t=e.index)!==null&&t!==void 0?t:0;return s.filter((e=>e.source===r)).map((e=>{const t=this.getParsed(e.target);t.index=e.target;return t}))}_parseDefinedEdge(e){const t=this.getDataset();const{data:s}=t;return{source:this.resolveNodeIndex(s,e.source),target:this.resolveNodeIndex(s,e.target),points:[]}}_parseEdges(){const e=this.getDataset();const t=e.data;const s=this._cachedMeta;if(e.edges){const t=e.edges.map((e=>this._parseDefinedEdge(e)));s._parsedEdges=t;return t}const r=[];s._parsedEdges=r;t.forEach(((e,s)=>{if(e.parent!=null){const a=this.resolveNodeIndex(t,e.parent);r.push({source:a,target:s,points:[]})}}));return r}addElements(){super.addElements();const e=this._cachedMeta;const t=this._parseEdges();const s=new Array(t.length);e.edges=s;for(let e=0;e<t.length;e+=1)s[e]=new this.edgeElementType}_resyncEdgeElements(){const e=this._cachedMeta;const t=this._parseEdges();const s=e.edges||(e.edges=[]);for(let e=0;e<t.length;e+=1)s[e]=s[e]||new this.edgeElementType;t.length<s.length&&s.splice(t.length,s.length)}_insertElements(e,t){s.prototype._insertElements.call(this,e,t);t>0&&this._resyncEdgeElements()}_removeElements(e,t){s.prototype._removeElements.call(this,e,t);t>0&&this._resyncEdgeElements()}_insertEdgeElements(e,t){const s=[];for(let e=0;e<t;e+=1)s.push(new this.edgeElementType);this._cachedMeta.edges.splice(e,0,...s);this.updateEdgeElements(s,e,"reset");this._scheduleResyncLayout()}reLayout(){}resetLayout(){}stopLayout(){}_scheduleResyncLayout(){this._scheduleResyncLayoutId!=null&&this._scheduleResyncLayoutId>=0||(this._scheduleResyncLayoutId=requestAnimationFrame((()=>{this._scheduleResyncLayoutId=-1;this.resyncLayout()})))}resyncLayout(){}}GraphController.id="graph";GraphController.defaults=h({},[s.defaults,{clip:10,animations:{points:{fn:interpolatePoints,properties:["points"]}},edgeElementType:EdgeLine.id}]);GraphController.overrides=h({},[s.overrides,{layout:{padding:10},scales:{x:{display:false,ticks:{maxTicksLimit:2,precision:100,minRotation:0,maxRotation:0}},y:{display:false,ticks:{maxTicksLimit:2,precision:100,minRotation:0,maxRotation:0}}},plugins:{tooltip:{callbacks:{label(e){var t,s;return(s=(t=e.chart.data)===null||t===void 0?void 0:t.labels)===null||s===void 0?void 0:s[e.dataIndex]}}}}}]);class GraphChart extends a{constructor(e,t){super(e,patchController("graph",t,GraphController,[EdgeLine,n],o))}}GraphChart.id=GraphController.id;class ForceDirectedGraphController extends GraphController{constructor(e,t){super(e,t);this._animTimer=-1;this._simulation=p().on("tick",(()=>{if(this.chart.canvas&&this._animTimer!==-2){this._copyPosition();this.chart.render()}else this._simulation.stop()})).on("end",(()=>{if(this.chart.canvas&&this._animTimer!==-2){this._copyPosition();this.chart.render();this.chart.update("default")}}));const s=this.options.simulation;const r={center:u,collide:m,link:g,manyBody:y,x:_,y:x,radial:f};Object.keys(r).forEach((e=>{const t=s.forces[e];if(!t)return;const a=r[e]();typeof t!=="boolean"&&Object.keys(t).forEach((e=>{a[e](t[e])}));this._simulation.force(e,a)}));this._simulation.stop()}_destroy(){this._animTimer>=0&&cancelAnimationFrame(this._animTimer);this._animTimer=-2;return super._destroy()}_copyPosition(){const e=this._cachedMeta._parsed;const t=e.reduce(((e,t)=>{const s=t._sim;if(!s||s.x==null||s.y==null)return e;s.x<e.minX&&(e.minX=s.x);s.x>e.maxX&&(e.maxX=s.x);s.y<e.minY&&(e.minY=s.y);s.y>e.maxY&&(e.maxY=s.y);return e}),{minX:Number.POSITIVE_INFINITY,maxX:Number.NEGATIVE_INFINITY,minY:Number.POSITIVE_INFINITY,maxY:Number.NEGATIVE_INFINITY});const rescaleX=e=>(e-t.minX)/(t.maxX-t.minX)*2-1;const rescaleY=e=>(e-t.minY)/(t.maxY-t.minY)*2-1;e.forEach((e=>{var t,s;if(e._sim){e.x=rescaleX((t=e._sim.x)!==null&&t!==void 0?t:0);e.y=rescaleY((s=e._sim.y)!==null&&s!==void 0?s:0)}}));const{xScale:s,yScale:r}=this._cachedMeta;const a=this._cachedMeta.data;a.forEach(((t,a)=>{var n,o;const i=e[a];Object.assign(t,{x:(n=s===null||s===void 0?void 0:s.getPixelForValue(i.x,a))!==null&&n!==void 0?n:0,y:(o=r===null||r===void 0?void 0:r.getPixelForValue(i.y,a))!==null&&o!==void 0?o:0,skip:false})}))}resetLayout(){super.resetLayout();this._simulation.stop();const e=this._cachedMeta._parsed.map(((e,t)=>{const s={...e};s.index=t;e._sim=s;if(!e.reset)return s;delete s.x;delete s.y;delete s.vx;delete s.vy;return s}));this._simulation.nodes(e);this._simulation.alpha(1).restart()}resyncLayout(){super.resyncLayout();this._simulation.stop();const e=this._cachedMeta;const t=e._parsed.map(((e,t)=>{const s={...e};s.index=t;e._sim=s;s.x===null&&delete s.x;s.y===null&&delete s.y;s.x==null&&s.y==null&&(e.reset=true);return s}));const s=this._simulation.force("link");s&&s.links([]);this._simulation.nodes(t);s&&s.links((e._parsedEdges||[]).map((e=>({...e}))));if(this.options.simulation.initialIterations>0){this._simulation.alpha(1);this._simulation.tick(this.options.simulation.initialIterations);this._copyPosition();if(this.options.simulation.autoRestart)this._simulation.restart();else if(this.chart.canvas!=null&&this._animTimer!==-2){const e=this.chart;this._animTimer=requestAnimationFrame((()=>{e.canvas&&e.update()}))}}else this.options.simulation.autoRestart&&this.chart.canvas!=null&&this._animTimer!==-2&&this._simulation.alpha(1).restart()}reLayout(){this._simulation.alpha(1).restart()}stopLayout(){super.stopLayout();this._simulation.stop()}}ForceDirectedGraphController.id="forceDirectedGraph";ForceDirectedGraphController.defaults=h({},[GraphController.defaults,{animation:false,simulation:{initialIterations:0,autoRestart:true,forces:{center:true,collide:false,link:true,manyBody:true,x:false,y:false,radial:false}}}]);ForceDirectedGraphController.overrides=h({},[GraphController.overrides,{scales:{x:{min:-1,max:1},y:{min:-1,max:1}}}]);class ForceDirectedGraphChart extends a{constructor(e,t){super(e,patchController("forceDirectedGraph",t,ForceDirectedGraphController,[EdgeLine,n],o))}}ForceDirectedGraphChart.id=ForceDirectedGraphController.id;class DendrogramController extends GraphController{constructor(){super(...arguments);this._animTimer=-1}updateEdgeElement(e,t,s,r){s._orientation=this.options.tree.orientation;super.updateEdgeElement(e,t,s,r)}_destroy(){this._animTimer>=0&&cancelAnimationFrame(this._animTimer);this._animTimer=-2;return super._destroy()}updateElement(e,t,s,r){t!=null&&(s.angle=this.getParsed(t).angle);super.updateElement(e,t,s,r)}resyncLayout(){const e=this._cachedMeta;e.root=E(this.getTreeRoot(),(e=>this.getTreeChildren(e))).count().sort(((e,t)=>{var s,r;return t.height-e.height||((s=t.data.index)!==null&&s!==void 0?s:0)-((r=e.data.index)!==null&&r!==void 0?r:0)}));this.doLayout(e.root);super.resyncLayout()}reLayout(e={}){if(e){Object.assign(this.options.tree,e);const t=this.getDataset();t.tree?Object.assign(t.tree,e):t.tree=e}this.doLayout(this._cachedMeta.root)}doLayout(e){const t=this.options.tree;const s=t.mode==="tree"?v():C();t.orientation==="radial"?s.size([Math.PI*2,1]):s.size([2,2]);const r={horizontal:e=>{e.data.x=e.y-1;e.data.y=1-e.x},vertical:e=>{e.data.x=e.x-1;e.data.y=1-e.y},radial:e=>{e.data.x=Math.cos(e.x)*e.y;e.data.y=Math.sin(e.x)*e.y;e.data.angle=e.y===0?Number.NaN:e.x}};s(e).each(r[t.orientation]||r.horizontal);const a=this.chart;this._animTimer!==-2&&(this._animTimer=requestAnimationFrame((()=>{a.canvas&&a.update()})))}}DendrogramController.id="dendrogram";DendrogramController.defaults=h({},[GraphController.defaults,{tree:{mode:"dendrogram",orientation:"horizontal"},animations:{numbers:{type:"number",properties:["x","y","angle","radius","rotation","borderWidth"]}},tension:.4}]);DendrogramController.overrides=h({},[GraphController.overrides,{scales:{x:{min:-1,max:1},y:{min:-1,max:1}}}]);class DendrogramChart extends a{constructor(e,t){super(e,patchController("dendrogram",t,DendrogramController,[EdgeLine,n],o))}}DendrogramChart.id=DendrogramController.id;class DendogramController extends DendrogramController{}DendogramController.id="dendogram";DendogramController.defaults=h({},[DendrogramController.defaults,{tree:{mode:"dendrogram"}}]);const T=DendrogramChart;class TreeController extends DendrogramController{}TreeController.id="tree";TreeController.defaults=h({},[DendrogramController.defaults,{tree:{mode:"tree"}}]);TreeController.overrides=DendrogramController.overrides;class TreeChart extends a{constructor(e,t){super(e,patchController("tree",t,TreeController,[EdgeLine,n],o))}}TreeChart.id=TreeController.id;export{T as DendogramChart,DendogramController,DendrogramChart,DendrogramController,EdgeLine,ForceDirectedGraphChart,ForceDirectedGraphController,GraphChart,GraphController,TreeChart,TreeController};

